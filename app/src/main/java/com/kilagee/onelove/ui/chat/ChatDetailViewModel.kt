package com.kilagee.onelove.ui.chat

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kilagee.onelove.data.model.Chat
import com.kilagee.onelove.data.model.Message
import com.kilagee.onelove.domain.model.Resource
import com.kilagee.onelove.domain.repository.AuthRepository
import com.kilagee.onelove.domain.repository.ChatRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import java.util.Date
import javax.inject.Inject

@HiltViewModel
class ChatDetailViewModel @Inject constructor(
    private val chatRepository: ChatRepository,
    private val authRepository: AuthRepository
) : ViewModel() {
    
    private val _chatState = MutableStateFlow<Resource<Chat>>(Resource.Loading)
    val chatState: StateFlow<Resource<Chat>> = _chatState
    
    private val _messagesState = MutableStateFlow<Resource<List<Message>>>(Resource.Loading)
    val messagesState: StateFlow<Resource<List<Message>>> = _messagesState
    
    fun loadChat(chatId: String) {
        viewModelScope.launch {
            chatRepository.getChatById(chatId)
                .onEach { resource ->
                    _chatState.value = resource
                    
                    // If successful load, mark as read
                    if (resource is Resource.Success) {
                        chatRepository.resetUnreadCount(chatId)
                    }
                }
                .catch { e ->
                    _chatState.value = Resource.error("Failed to load chat: ${e.message}")
                }
                .launchIn(viewModelScope)
        }
    }
    
    fun loadMessages(chatId: String) {
        viewModelScope.launch {
            chatRepository.getMessagesByChatId(chatId)
                .onEach { resource ->
                    _messagesState.value = resource
                    
                    // Mark messages as read if successful
                    if (resource is Resource.Success) {
                        val messages = resource.data
                        val currentUserId = getCurrentUserId()
                        
                        // Find messages that are not from current user and not read yet
                        val unreadMessages = messages.filter { 
                            it.receiverId == currentUserId && it.readAt == null 
                        }
                        
                        // Mark them as read
                        unreadMessages.forEach { message ->
                            message.id?.let { messageId ->
                                chatRepository.markMessageAsRead(messageId)
                            }
                        }
                    }
                }
                .catch { e ->
                    _messagesState.value = Resource.error("Failed to load messages: ${e.message}")
                }
                .launchIn(viewModelScope)
        }
    }
    
    fun sendMessage(chatId: String, text: String) {
        viewModelScope.launch {
            val currentUserId = getCurrentUserId() ?: return@launch
            
            // Get the chat to determine the receiver ID
            val chatResult = chatRepository.getChatById(chatId).catch { }.collect { resource ->
                if (resource is Resource.Success) {
                    val chat = resource.data
                    val receiverId = if (chat.user1Id == currentUserId) chat.user2Id else chat.user1Id
                    
                    // Create message object
                    val message = Message(
                        id = null, // Will be generated by Firebase
                        chatId = chatId,
                        senderId = currentUserId,
                        receiverId = receiverId,
                        text = text,
                        imageUrl = null,
                        videoUrl = null,
                        audioUrl = null,
                        sentAt = Date(),
                        deliveredAt = null,
                        readAt = null,
                        isDeleted = false
                    )
                    
                    // Send message
                    chatRepository.sendMessage(message)
                        .onEach { messageResource ->
                            if (messageResource is Resource.Success) {
                                // Update chat with last message
                                chatRepository.updateLastMessage(
                                    chatId = chatId,
                                    messageId = messageResource.data.id!!,
                                    lastMessageText = text
                                )
                                
                                // Reload messages
                                loadMessages(chatId)
                            }
                        }
                        .catch { e ->
                            // Handle error
                            _messagesState.value = Resource.error("Failed to send message: ${e.message}")
                        }
                        .launchIn(viewModelScope)
                }
            }
        }
    }
    
    fun getCurrentUserId(): String? {
        return authRepository.getCurrentUser().value?.data?.id
    }
}